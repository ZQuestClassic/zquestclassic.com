{% extends "layouts/base.njk" %}

{% block header %}
<style>
	li {
		margin-bottom: 10px;
	}

	.release-header {
		display: flex;
		justify-content: space-between;
    	width: 100%;
		padding: 10px;
	}

	.release-navigation {
	}
	.release-meta {
		display: flex;
		flex-wrap: wrap;
		gap: 10px;
	}
	.release-meta {
	}

	.title {
		font-size: 2em;
	}

	.nav-wrapper {
		display: flex;
		justify-content: center;
		position: relative;
	}
	.toc {
		top: 0;
		/* position: fixed; */
		position: sticky;
		/* left: 1em; */
		/* top: 5em; */
		/* padding: 1em; */
		/* width: 10em; */
		font-size: 0.9em;
		align-self: baseline;
		padding: 5px 20px;
		overflow: auto;
    	height: 100vh;
	}
	@media only screen and (max-width: 600px) {
		.toc {
			display: none;
		}
	}

	.toc ul, .toc li {
		list-style: none;
		padding: 0;
		margin: 0;
	}
	.toc ul ul {
		padding-left: 2em;
	}
	.toc li a {
		display: inline-block;
		color: var(--text-color);
		text-decoration: none;
		transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
	}
	.toc li a:visited {
		color: var(--text-color);
	}
	.toc li.visible > a {
		color: hsl(65, 80%, 42%);
		transform: translate(5px);
	}
	.toc-marker {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		z-index: -1;
	}
	.toc-marker path {
		transition: all 0.3s ease;
	}
	/* .contents {
		padding: 1em;
		max-width: 800px;
		font-size: 1.2em;
		font-family: 'Frank Ruhl Libre', sans-serif;
	}
	.contents img {
		max-width: 100%;
	}
	.contents .code-block {
		white-space: pre;
		overflow: auto;
		max-width: 100%;
	}
	.contents .code-block code {
		display: block;
		background-color: #f9f9f9;
		padding: 10px;
	}
	.contents .code-inline {
		background-color: #f9f9f9;
		padding: 4px;
	}
	.contents h2 h3 {
		padding-top: 1em;
	}
	.contents h2 {
		margin-top: 1.2em;
	} */
</style>

<div class="release-header">
	<div class="release-navigation">
		<span><a href="/releases">All Releases</a></span>
	
		{%- set previousRelease = collections.releases | getPreviousCollectionItem %}
		{%- set nextRelease = collections.releases | getNextCollectionItem %}
		{%- if nextRelease or previousRelease %}
		<span>| </span>
		{%- if previousRelease %}<span><a href="{{ previousRelease.url }}">{{ previousRelease.data.title }}</a> -> </span>{%
		endif %}
		<span>{{ title }}</span>
		{%- if nextRelease %}<span> -> <a href="{{ nextRelease.url }}">{{ nextRelease.data.title }}</a></span>{% endif %}
		{%- endif %}
	</div>

	<div class="release-meta">
		<div>
			<time datetime="{{ page.date | htmlDateString }}">{{ page.date | readableDate }}</time>
		</div>
		<a href="https://www.github.com/ZQuestClassic/ZQuestClassic/releases/tag/{{ tag_name }}" target="_blank">View on GitHub</a>
	</div>
</div>

{% endblock %}

{% block content %}

{# Fancy nav styles adapted from https://lab.hakim.se/progress-nav/ #}

<div class="nav-wrapper">
	<nav class="toc">
		<svg class="toc-marker" width="200" height="200" xmlns="http://www.w3.org/2000/svg">
			<path stroke="#b3c115" stroke-width="3" fill="transparent" stroke-dasharray="0, 0, 0, 1000" stroke-linecap="round" stroke-linejoin="round" transform="translate(-0.5, -0.5)" />
		</svg>
	</nav>

	<div>
		<div class="title">{{ title }}</div>

		{%- if description %}
			<h2>{{ description }}</h2>
		{%- endif %}
	
		<style>
			.assets {
				display: flex;
				flex-wrap: wrap;
				margin: 10px;
			}
	
			.download-asset {
				flex: 1;
				display: flex;
				align-items: center;
				justify-content: space-evenly;
				padding: 10px;
				margin: 10px;
				border: 2px solid black;
				border-radius: 25px;
				background-color: #423f56;
				text-decoration: none;
			}
			.download-asset:hover {
				background-color: #4d4964;
			}
			.download-asset.selected {
				border-color: hsl(65, 80%, 42%);
			}
	
			.download-asset img {
				width: 40px;
				height: 40px;
			}
			.download-asset .label {
				padding: 10px;
				text-align: center;
			}
		</style>
	
		<div class="assets">
			{% for asset in assets %}
				<a class="download-asset" alt="{{ asset.channel }}" data-channel="{{ asset.channel }}" href="{{ asset.name }}">
					{% if 'windows' in asset.channel %}
						<img src="/img/windows.svg">
					{% else %}
						<img src="/img/{{ asset.channel }}.svg">
					{% endif %}
					<div class="label">
						{% if asset.channel == 'windows-x64' %}
							<div>Windows</div>
							<div>64-bit</div>
						{% elif asset.channel == 'windows-win32' %}
							<div>Windows</div>
							<div>32-bit</div>
						{% else %}
							{{ asset.channel | capitalize }}
						{% endif %}
					</div>
				</a>
			{% endfor %}
		</div>
	
		<div>Downloads: <span class="download-count"></span></div>
	
		<script>
			const assets = Website.sortAssets({{ assets | json | safe }});
			const channel = Website.getChannel();
			let order = 0;
			for (const asset of assets) {
				const el = document.querySelector(`[data-channel="${asset.channel}"]`);
				el.style.order = order++;
				if (asset.channel === channel) el.classList.add('selected');
			}
	
			(async () => {
				const json = await Website.getReleaseInfo('{{ tag_name }}');
				let downloads = 0;
				for (const asset of json.assets) downloads += asset.download_count;
				document.querySelector('.download-count').textContent = downloads;
			})();
		</script>
	
	
		{{ super() | safe }}
	</div>
</div>


<script>

function getTree(array) {
	const root = {children: []};
	const lastByRank = {
		0: root,
	};
	for (let i = 0; i < array.length; i++) {
		const o = array[i];

		let parent;
		let j = o.rank - 1;
		while (j >= 0) {
			if (lastByRank[j]) {
				parent = lastByRank[j];
				break;
			}
			j -= 1;
		}

		const node = {el: o.el, text: o.text, children: []};
		parent.children.push(node);
		lastByRank[o.rank] = node;
	}

	return root;
}

function makeId(text) {
	return text
		.toLowerCase()
		.replace(/\.|%[0-9a-z]{2}/gi, '')
		.replace(/\s+/g, '-');
}

function handleNode(node, parentEl, prefix = []) {
	const el = document.createElement('li');
	const newPrefix = [...prefix, makeId(node.text || '')];
	if (node.text) {
		const id = newPrefix.join('-');
		const aEl = document.createElement('a');
		aEl.textContent = node.text;
		aEl.href = `#${id}`;
		node.el.id = id;
		el.append(aEl);
	}
	parentEl.append(el);
	if (!node.children.length) return;

	const ul = document.createElement('ul');
	el.append(ul);
	for (const child of node.children) {
		handleNode(child, ul, newPrefix);
	}
}

const contentEl =document.body.querySelector('.content');
const flat = [...contentEl.querySelectorAll('h1,h2,h3,h4')].map(el => {
	return {el, text: el.textContent, rank: Number(el.tagName.substring(1))};
});
if (flat.length) {
	const tree = getTree(flat);
	console.log(tree);
	const rootNavEl = document.createElement('ul');
	handleNode(tree, rootNavEl);
	document.querySelector('.toc').append(rootNavEl);
}


window.onload = function() {

var toc = document.querySelector( '.toc' );
var tocMarker = document.querySelector( '.toc-marker' );
var tocPath = document.querySelector( '.toc-marker path' );
var tocItems;

// Factor of screen size that the element must cross
// before it's considered visible
var TOP_MARGIN = 0,
	BOTTOM_MARGIN = 0;

var pathLength;

var lastPathStart,
	lastPathEnd;

window.addEventListener( 'resize', drawPath, false );
window.addEventListener( 'scroll', sync, false );

drawPath();

function drawPath() {
	tocItems = [].slice.call( toc.querySelectorAll( 'li' ) );

	// Cache element references and measurements
	tocItems = tocItems.map( function( item ) {
		var anchor = item.querySelector( 'a' );
		var target = document.getElementById( anchor.getAttribute( 'href' ).slice( 1 ) );

		return {
			listItem: item,
			anchor: anchor,
			target: target
		};
	} );

	// Remove missing targets
	tocItems = tocItems.filter( function( item ) {
		return !!item.target;
	} );

	var path = [];
	var pathIndent;

	tocItems.forEach( function( item, i ) {

		var x = item.anchor.offsetLeft - 5,
			y = item.anchor.offsetTop,
			height = item.anchor.offsetHeight;

		if( i === 0 ) {
			path.push( 'M', x, y, 'L', x, y + height );
			item.pathStart = 0;
		}
		else {
			// Draw an additional line when there's a change in
			// indent levels
			if( pathIndent !== x ) path.push( 'L', pathIndent, y );

			path.push( 'L', x, y );

			// Set the current path so that we can measure it
			tocPath.setAttribute( 'd', path.join( ' ' ) );
			item.pathStart = tocPath.getTotalLength() || 0;

			path.push( 'L', x, y + height );
		}

		pathIndent = x;

		tocPath.setAttribute( 'd', path.join( ' ' ) );
		item.pathEnd = tocPath.getTotalLength();

	} );

	pathLength = tocPath.getTotalLength();

	sync();

}

function sync() {

	var windowHeight = window.innerHeight;

	var pathStart = pathLength,
		pathEnd = 0;

	var visibleItems = 0;

	tocMarker.setAttribute('height', toc.querySelector('ul').clientHeight);

	const viz = [];

	tocItems.forEach( function( item ) {
		var targetBounds = item.target.getBoundingClientRect();
		if( targetBounds.bottom > windowHeight * TOP_MARGIN && targetBounds.top < windowHeight * ( 1 - BOTTOM_MARGIN ) ) {
			viz.push(item);
			visibleItems += 1;
		}
	} );

	if (viz.length === 0) return;

	tocItems.forEach( function( item ) {
		if (viz.includes(item)) {
			pathStart = Math.min( item.pathStart, pathStart );
			pathEnd = Math.max( item.pathEnd, pathEnd );

			visibleItems += 1;

			item.listItem.classList.add( 'visible' );

			const rect = item.anchor.getBoundingClientRect()
			if (!(rect.top <= window.innerHeight && rect.bottom >= 0)) {
				// item.anchor.scrollIntoView({behavior: 'smooth'});
				// item.anchor.scrollIntoView(true);
				toc.scrollTop += rect.y;
			}
		}
		else {
			item.listItem.classList.remove( 'visible' );
		}
	} );

	// Specify the visible path or hide the path altogether
	// if there are no visible items
	if( visibleItems > 0 && pathStart < pathEnd ) {
		if( pathStart !== lastPathStart || pathEnd !== lastPathEnd ) {
			tocPath.setAttribute( 'stroke-dashoffset', '1' );
			tocPath.setAttribute( 'stroke-dasharray', '1, '+ pathStart +', '+ ( pathEnd - pathStart ) +', ' + pathLength );
			tocPath.setAttribute( 'opacity', 1 );
		}
	}
	else {
		tocPath.setAttribute( 'opacity', 0 );
	}

	lastPathStart = pathStart;
	lastPathEnd = pathEnd;

}

};
</script>

{% endblock %}
